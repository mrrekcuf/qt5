/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
*/

#include "config.h"

#if ENABLE(RESOURCE_TIMING)

#include "JSPerformanceResourceTiming.h"

#include "KURL.h"
#include "PerformanceResourceTiming.h"
#include <runtime/JSString.h>
#include <wtf/GetPtr.h>

using namespace JSC;

namespace WebCore {

/* Hash table */

static const HashTableValue JSPerformanceResourceTimingTableValues[] =
{
    { "initiatorType", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingInitiatorType), (intptr_t)0, NoIntrinsic },
    { "redirectStart", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingRedirectStart), (intptr_t)0, NoIntrinsic },
    { "redirectEnd", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingRedirectEnd), (intptr_t)0, NoIntrinsic },
    { "fetchStart", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingFetchStart), (intptr_t)0, NoIntrinsic },
    { "domainLookupStart", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingDomainLookupStart), (intptr_t)0, NoIntrinsic },
    { "domainLookupEnd", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingDomainLookupEnd), (intptr_t)0, NoIntrinsic },
    { "connectStart", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingConnectStart), (intptr_t)0, NoIntrinsic },
    { "connectEnd", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingConnectEnd), (intptr_t)0, NoIntrinsic },
    { "secureConnectionStart", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingSecureConnectionStart), (intptr_t)0, NoIntrinsic },
    { "requestStart", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingRequestStart), (intptr_t)0, NoIntrinsic },
    { "responseStart", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingResponseStart), (intptr_t)0, NoIntrinsic },
    { "responseEnd", DontDelete | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingResponseEnd), (intptr_t)0, NoIntrinsic },
    { "constructor", DontEnum | ReadOnly, (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsPerformanceResourceTimingConstructor), (intptr_t)0, NoIntrinsic },
    { 0, 0, 0, 0, NoIntrinsic }
};

static const HashTable JSPerformanceResourceTimingTable = { 34, 31, JSPerformanceResourceTimingTableValues, 0 };
/* Hash table for constructor */

static const HashTableValue JSPerformanceResourceTimingConstructorTableValues[] =
{
    { 0, 0, 0, 0, NoIntrinsic }
};

static const HashTable JSPerformanceResourceTimingConstructorTable = { 1, 0, JSPerformanceResourceTimingConstructorTableValues, 0 };
const ClassInfo JSPerformanceResourceTimingConstructor::s_info = { "PerformanceResourceTimingConstructor", &Base::s_info, &JSPerformanceResourceTimingConstructorTable, 0, CREATE_METHOD_TABLE(JSPerformanceResourceTimingConstructor) };

JSPerformanceResourceTimingConstructor::JSPerformanceResourceTimingConstructor(Structure* structure, JSDOMGlobalObject* globalObject)
    : DOMConstructorObject(structure, globalObject)
{
}

void JSPerformanceResourceTimingConstructor::finishCreation(ExecState* exec, JSDOMGlobalObject* globalObject)
{
    Base::finishCreation(exec->vm());
    ASSERT(inherits(&s_info));
    putDirect(exec->vm(), exec->propertyNames().prototype, JSPerformanceResourceTimingPrototype::self(exec, globalObject), DontDelete | ReadOnly);
    putDirect(exec->vm(), exec->propertyNames().length, jsNumber(0), ReadOnly | DontDelete | DontEnum);
}

bool JSPerformanceResourceTimingConstructor::getOwnPropertySlot(JSCell* cell, ExecState* exec, PropertyName propertyName, PropertySlot& slot)
{
    return getStaticValueSlot<JSPerformanceResourceTimingConstructor, JSDOMWrapper>(exec, &JSPerformanceResourceTimingConstructorTable, jsCast<JSPerformanceResourceTimingConstructor*>(cell), propertyName, slot);
}

bool JSPerformanceResourceTimingConstructor::getOwnPropertyDescriptor(JSObject* object, ExecState* exec, PropertyName propertyName, PropertyDescriptor& descriptor)
{
    return getStaticValueDescriptor<JSPerformanceResourceTimingConstructor, JSDOMWrapper>(exec, &JSPerformanceResourceTimingConstructorTable, jsCast<JSPerformanceResourceTimingConstructor*>(object), propertyName, descriptor);
}

/* Hash table for prototype */

static const HashTableValue JSPerformanceResourceTimingPrototypeTableValues[] =
{
    { 0, 0, 0, 0, NoIntrinsic }
};

static const HashTable JSPerformanceResourceTimingPrototypeTable = { 1, 0, JSPerformanceResourceTimingPrototypeTableValues, 0 };
const ClassInfo JSPerformanceResourceTimingPrototype::s_info = { "PerformanceResourceTimingPrototype", &Base::s_info, &JSPerformanceResourceTimingPrototypeTable, 0, CREATE_METHOD_TABLE(JSPerformanceResourceTimingPrototype) };

JSObject* JSPerformanceResourceTimingPrototype::self(ExecState* exec, JSGlobalObject* globalObject)
{
    return getDOMPrototype<JSPerformanceResourceTiming>(exec, globalObject);
}

const ClassInfo JSPerformanceResourceTiming::s_info = { "PerformanceResourceTiming", &Base::s_info, &JSPerformanceResourceTimingTable, 0 , CREATE_METHOD_TABLE(JSPerformanceResourceTiming) };

JSPerformanceResourceTiming::JSPerformanceResourceTiming(Structure* structure, JSDOMGlobalObject* globalObject, PassRefPtr<PerformanceResourceTiming> impl)
    : JSPerformanceEntry(structure, globalObject, impl)
{
}

void JSPerformanceResourceTiming::finishCreation(VM& vm)
{
    Base::finishCreation(vm);
    ASSERT(inherits(&s_info));
}

JSObject* JSPerformanceResourceTiming::createPrototype(ExecState* exec, JSGlobalObject* globalObject)
{
    return JSPerformanceResourceTimingPrototype::create(exec->vm(), globalObject, JSPerformanceResourceTimingPrototype::createStructure(exec->vm(), globalObject, JSPerformanceEntryPrototype::self(exec, globalObject)));
}

bool JSPerformanceResourceTiming::getOwnPropertySlot(JSCell* cell, ExecState* exec, PropertyName propertyName, PropertySlot& slot)
{
    JSPerformanceResourceTiming* thisObject = jsCast<JSPerformanceResourceTiming*>(cell);
    ASSERT_GC_OBJECT_INHERITS(thisObject, &s_info);
    return getStaticValueSlot<JSPerformanceResourceTiming, Base>(exec, &JSPerformanceResourceTimingTable, thisObject, propertyName, slot);
}

bool JSPerformanceResourceTiming::getOwnPropertyDescriptor(JSObject* object, ExecState* exec, PropertyName propertyName, PropertyDescriptor& descriptor)
{
    JSPerformanceResourceTiming* thisObject = jsCast<JSPerformanceResourceTiming*>(object);
    ASSERT_GC_OBJECT_INHERITS(thisObject, &s_info);
    return getStaticValueDescriptor<JSPerformanceResourceTiming, Base>(exec, &JSPerformanceResourceTimingTable, thisObject, propertyName, descriptor);
}

JSValue jsPerformanceResourceTimingInitiatorType(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsStringWithCache(exec, impl->initiatorType());
    return result;
}


JSValue jsPerformanceResourceTimingRedirectStart(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->redirectStart());
    return result;
}


JSValue jsPerformanceResourceTimingRedirectEnd(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->redirectEnd());
    return result;
}


JSValue jsPerformanceResourceTimingFetchStart(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->fetchStart());
    return result;
}


JSValue jsPerformanceResourceTimingDomainLookupStart(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->domainLookupStart());
    return result;
}


JSValue jsPerformanceResourceTimingDomainLookupEnd(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->domainLookupEnd());
    return result;
}


JSValue jsPerformanceResourceTimingConnectStart(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->connectStart());
    return result;
}


JSValue jsPerformanceResourceTimingConnectEnd(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->connectEnd());
    return result;
}


JSValue jsPerformanceResourceTimingSecureConnectionStart(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->secureConnectionStart());
    return result;
}


JSValue jsPerformanceResourceTimingRequestStart(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->requestStart());
    return result;
}


JSValue jsPerformanceResourceTimingResponseStart(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->responseStart());
    return result;
}


JSValue jsPerformanceResourceTimingResponseEnd(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* castedThis = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    PerformanceResourceTiming* impl = static_cast<PerformanceResourceTiming*>(castedThis->impl());
    JSValue result = jsNumber(impl->responseEnd());
    return result;
}


JSValue jsPerformanceResourceTimingConstructor(ExecState* exec, JSValue slotBase, PropertyName)
{
    JSPerformanceResourceTiming* domObject = jsCast<JSPerformanceResourceTiming*>(asObject(slotBase));
    return JSPerformanceResourceTiming::getConstructor(exec, domObject->globalObject());
}

JSValue JSPerformanceResourceTiming::getConstructor(ExecState* exec, JSGlobalObject* globalObject)
{
    return getDOMConstructor<JSPerformanceResourceTimingConstructor>(exec, jsCast<JSDOMGlobalObject*>(globalObject));
}


}

#endif // ENABLE(RESOURCE_TIMING)
