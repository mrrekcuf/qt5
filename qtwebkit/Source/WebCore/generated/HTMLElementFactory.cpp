/*
 * THIS FILE WAS AUTOMATICALLY GENERATED, DO NOT EDIT.
 *
 * This file was generated by the dom/make_names.pl script.
 *
 * Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "HTMLElementFactory.h"
#include "HTMLNames.h"
#include "HTMLAnchorElement.h"
#include "HTMLElement.h"
#include "HTMLAppletElement.h"
#include "HTMLAreaElement.h"
#include "HTMLBaseElement.h"
#include "HTMLBaseFontElement.h"
#include "HTMLBDIElement.h"
#include "HTMLQuoteElement.h"
#include "HTMLBodyElement.h"
#include "HTMLBRElement.h"
#include "HTMLButtonElement.h"
#include "HTMLCanvasElement.h"
#include "HTMLTableCaptionElement.h"
#include "HTMLTableColElement.h"
#include "HTMLModElement.h"
#include "HTMLDirectoryElement.h"
#include "HTMLDivElement.h"
#include "HTMLDListElement.h"
#include "HTMLEmbedElement.h"
#include "HTMLFieldSetElement.h"
#include "HTMLFontElement.h"
#include "HTMLFormElement.h"
#include "HTMLFrameElement.h"
#include "HTMLFrameSetElement.h"
#include "HTMLHeadingElement.h"
#include "HTMLHeadElement.h"
#include "HTMLHRElement.h"
#include "HTMLHtmlElement.h"
#include "HTMLIFrameElement.h"
#include "HTMLImageElement.h"
#include "HTMLInputElement.h"
#include "HTMLUnknownElement.h"
#include "HTMLKeygenElement.h"
#include "HTMLLabelElement.h"
#include "HTMLLegendElement.h"
#include "HTMLLIElement.h"
#include "HTMLLinkElement.h"
#include "HTMLPreElement.h"
#include "HTMLMapElement.h"
#include "HTMLMarqueeElement.h"
#include "HTMLMenuElement.h"
#include "HTMLMetaElement.h"
#include "HTMLObjectElement.h"
#include "HTMLOListElement.h"
#include "HTMLOptGroupElement.h"
#include "HTMLOptionElement.h"
#include "HTMLOutputElement.h"
#include "HTMLParagraphElement.h"
#include "HTMLParamElement.h"
#include "HTMLScriptElement.h"
#include "HTMLSelectElement.h"
#include "HTMLSpanElement.h"
#include "HTMLStyleElement.h"
#include "HTMLTableElement.h"
#include "HTMLTableSectionElement.h"
#include "HTMLTableCellElement.h"
#include "HTMLTextAreaElement.h"
#include "HTMLTitleElement.h"
#include "HTMLTableRowElement.h"
#include "HTMLUListElement.h"
#include "HTMLUnknownElement.h"

#include <wtf/HashMap.h>

#if ENABLE(DATALIST_ELEMENT)
#include "HTMLDataListElement.h"
#endif

#if ENABLE(DETAILS_ELEMENT)
#include "HTMLDetailsElement.h"
#include "HTMLSummaryElement.h"
#endif

#if ENABLE(DIALOG_ELEMENT)
#include "HTMLDialogElement.h"
#endif

#if ENABLE(METER_ELEMENT)
#include "HTMLMeterElement.h"
#endif

#if ENABLE(PROGRESS_ELEMENT)
#include "HTMLProgressElement.h"
#endif

#if ENABLE(SHADOW_DOM)
#include "HTMLContentElement.h"
#endif

#if ENABLE(TEMPLATE_ELEMENT)
#include "HTMLTemplateElement.h"
#endif

#if ENABLE(VIDEO)
#include "HTMLAudioElement.h"
#include "HTMLSourceElement.h"
#include "HTMLVideoElement.h"
#endif

#if ENABLE(VIDEO_TRACK)
#include "HTMLTrackElement.h"
#endif

#include "ContextFeatures.h"
#include "RuntimeEnabledFeatures.h"

#if ENABLE(CUSTOM_ELEMENTS)
#include "CustomElementConstructor.h"
#include "CustomElementRegistry.h"
#endif

#if ENABLE(DASHBOARD_SUPPORT) || ENABLE(VIDEO)
#include "Document.h"
#include "Settings.h"
#endif

namespace WebCore {

using namespace HTMLNames;

typedef PassRefPtr<HTMLElement> (*ConstructorFunction)(const QualifiedName&, Document*, HTMLFormElement*, bool createdByParser);
typedef HashMap<AtomicStringImpl*, ConstructorFunction> FunctionMap;

static FunctionMap* gFunctionMap = 0;

static PassRefPtr<HTMLElement> anchorConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLAnchorElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> Constructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> appletConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool createdByParser)
{
    return HTMLAppletElement::create(tagName, document, createdByParser);
}

static PassRefPtr<HTMLElement> areaConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLAreaElement::create(tagName, document);
}

#if ENABLE(VIDEO)

static PassRefPtr<HTMLElement> audioConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool createdByParser)
{
    Settings* settings = document->settings();
    if (!MediaPlayer::isAvailable() || (settings && !settings->mediaEnabled()))
        return 0;
    
    return HTMLAudioElement::create(tagName, document, createdByParser);
}

#endif
static PassRefPtr<HTMLElement> baseConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLBaseElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> basefontConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLBaseFontElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> bdiConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLBDIElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> quoteConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLQuoteElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> bodyConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLBodyElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> brConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLBRElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> buttonConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement* formElement, bool)
{
    return HTMLButtonElement::create(tagName, document, formElement);
}

static PassRefPtr<HTMLElement> canvasConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLCanvasElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> tablecaptionConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLTableCaptionElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> tablecolConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLTableColElement::create(tagName, document);
}

#if ENABLE(SHADOW_DOM)

static PassRefPtr<HTMLElement> contentConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    if (!RuntimeEnabledFeatures::shadowDOMEnabled())
        return 0;
    return HTMLContentElement::create(tagName, document);
}

#endif
#if ENABLE(DATALIST_ELEMENT)

static PassRefPtr<HTMLElement> datalistConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLDataListElement::create(tagName, document);
}

#endif
static PassRefPtr<HTMLElement> modConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLModElement::create(tagName, document);
}

#if ENABLE(DETAILS_ELEMENT)

static PassRefPtr<HTMLElement> detailsConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLDetailsElement::create(tagName, document);
}

#endif
#if ENABLE(DIALOG_ELEMENT)

static PassRefPtr<HTMLElement> dialogConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    if (!ContextFeatures::dialogElementEnabled(document))
        return 0;
    return HTMLDialogElement::create(tagName, document);
}

#endif
static PassRefPtr<HTMLElement> directoryConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLDirectoryElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> divConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLDivElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> dlistConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLDListElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> embedConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool createdByParser)
{
    return HTMLEmbedElement::create(tagName, document, createdByParser);
}

static PassRefPtr<HTMLElement> fieldsetConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement* formElement, bool)
{
    return HTMLFieldSetElement::create(tagName, document, formElement);
}

static PassRefPtr<HTMLElement> fontConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLFontElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> formConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLFormElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> frameConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLFrameElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> framesetConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLFrameSetElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> headingConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLHeadingElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> headConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLHeadElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> hrConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLHRElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> htmlConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLHtmlElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> iframeConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLIFrameElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> imageConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement* formElement, bool)
{
    return HTMLImageElement::create(tagName, document, formElement);
}

static PassRefPtr<HTMLElement> inputConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement* formElement, bool createdByParser)
{
    return HTMLInputElement::create(tagName, document, formElement, createdByParser);
}

static PassRefPtr<HTMLElement> unknownConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLUnknownElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> keygenConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement* formElement, bool)
{
    return HTMLKeygenElement::create(tagName, document, formElement);
}

static PassRefPtr<HTMLElement> labelConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLLabelElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> legendConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLLegendElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> liConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLLIElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> linkConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool createdByParser)
{
    return HTMLLinkElement::create(tagName, document, createdByParser);
}

static PassRefPtr<HTMLElement> preConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLPreElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> mapConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLMapElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> marqueeConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLMarqueeElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> menuConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLMenuElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> metaConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLMetaElement::create(tagName, document);
}

#if ENABLE(METER_ELEMENT)

static PassRefPtr<HTMLElement> meterConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLMeterElement::create(tagName, document);
}

#endif
static PassRefPtr<HTMLElement> objectConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement* formElement, bool createdByParser)
{
    return HTMLObjectElement::create(tagName, document, formElement, createdByParser);
}

static PassRefPtr<HTMLElement> olistConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLOListElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> optgroupConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLOptGroupElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> optionConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLOptionElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> outputConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement* formElement, bool)
{
    return HTMLOutputElement::create(tagName, document, formElement);
}

static PassRefPtr<HTMLElement> paragraphConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLParagraphElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> paramConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLParamElement::create(tagName, document);
}

#if ENABLE(PROGRESS_ELEMENT)

static PassRefPtr<HTMLElement> progressConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLProgressElement::create(tagName, document);
}

#endif
static PassRefPtr<HTMLElement> scriptConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool createdByParser)
{
    return HTMLScriptElement::create(tagName, document, createdByParser);
}

static PassRefPtr<HTMLElement> selectConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement* formElement, bool)
{
    return HTMLSelectElement::create(tagName, document, formElement);
}

#if ENABLE(VIDEO)

static PassRefPtr<HTMLElement> sourceConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    Settings* settings = document->settings();
    if (!MediaPlayer::isAvailable() || (settings && !settings->mediaEnabled()))
        return 0;
    
    return HTMLSourceElement::create(tagName, document);
}

#endif
static PassRefPtr<HTMLElement> spanConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLSpanElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> styleConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool createdByParser)
{
    return HTMLStyleElement::create(tagName, document, createdByParser);
}

#if ENABLE(DETAILS_ELEMENT)

static PassRefPtr<HTMLElement> summaryConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLSummaryElement::create(tagName, document);
}

#endif
static PassRefPtr<HTMLElement> tableConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLTableElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> tablesectionConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLTableSectionElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> tablecellConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLTableCellElement::create(tagName, document);
}

#if ENABLE(TEMPLATE_ELEMENT)

static PassRefPtr<HTMLElement> templateConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLTemplateElement::create(tagName, document);
}

#endif
static PassRefPtr<HTMLElement> textareaConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement* formElement, bool)
{
    return HTMLTextAreaElement::create(tagName, document, formElement);
}

static PassRefPtr<HTMLElement> titleConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLTitleElement::create(tagName, document);
}

static PassRefPtr<HTMLElement> tablerowConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLTableRowElement::create(tagName, document);
}

#if ENABLE(VIDEO_TRACK)

static PassRefPtr<HTMLElement> trackConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    Settings* settings = document->settings();
    if (!MediaPlayer::isAvailable() || (settings && !settings->mediaEnabled()))
        return 0;
    
    return HTMLTrackElement::create(tagName, document);
}

#endif
static PassRefPtr<HTMLElement> ulistConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool)
{
    return HTMLUListElement::create(tagName, document);
}

#if ENABLE(VIDEO)

static PassRefPtr<HTMLElement> videoConstructor(const QualifiedName& tagName, Document* document, HTMLFormElement*, bool createdByParser)
{
    Settings* settings = document->settings();
    if (!MediaPlayer::isAvailable() || (settings && !settings->mediaEnabled()))
        return 0;
    
    return HTMLVideoElement::create(tagName, document, createdByParser);
}

#endif
static void addTag(const QualifiedName& tag, ConstructorFunction func)
{
    gFunctionMap->set(tag.localName().impl(), func);
}

static void createFunctionMap()
{
    ASSERT(!gFunctionMap);

    // Create the table.
    gFunctionMap = new FunctionMap;
    
    // Populate it with constructor functions.
    addTag(aTag, anchorConstructor);
    addTag(abbrTag, Constructor);
    addTag(acronymTag, Constructor);
    addTag(addressTag, Constructor);
    addTag(appletTag, appletConstructor);
    addTag(areaTag, areaConstructor);
    addTag(articleTag, Constructor);
    addTag(asideTag, Constructor);
#if ENABLE(VIDEO)
    addTag(audioTag, audioConstructor);
#endif

    addTag(bTag, Constructor);
    addTag(baseTag, baseConstructor);
    addTag(basefontTag, basefontConstructor);
    addTag(bdiTag, bdiConstructor);
    addTag(bdoTag, Constructor);
    addTag(bgsoundTag, Constructor);
    addTag(bigTag, Constructor);
    addTag(blockquoteTag, quoteConstructor);
    addTag(bodyTag, bodyConstructor);
    addTag(brTag, brConstructor);
    addTag(buttonTag, buttonConstructor);
    addTag(canvasTag, canvasConstructor);
    addTag(captionTag, tablecaptionConstructor);
    addTag(centerTag, Constructor);
    addTag(citeTag, Constructor);
    addTag(codeTag, Constructor);
    addTag(colTag, tablecolConstructor);
    addTag(colgroupTag, tablecolConstructor);
    addTag(commandTag, Constructor);
#if ENABLE(SHADOW_DOM)
    addTag(contentTag, contentConstructor);
#endif

#if ENABLE(DATALIST_ELEMENT)
    addTag(datalistTag, datalistConstructor);
#endif

    addTag(ddTag, Constructor);
    addTag(delTag, modConstructor);
#if ENABLE(DETAILS_ELEMENT)
    addTag(detailsTag, detailsConstructor);
#endif

    addTag(dfnTag, Constructor);
#if ENABLE(DIALOG_ELEMENT)
    addTag(dialogTag, dialogConstructor);
#endif

    addTag(dirTag, directoryConstructor);
    addTag(divTag, divConstructor);
    addTag(dlTag, dlistConstructor);
    addTag(dtTag, Constructor);
    addTag(emTag, Constructor);
    addTag(embedTag, embedConstructor);
    addTag(fieldsetTag, fieldsetConstructor);
    addTag(figcaptionTag, Constructor);
    addTag(figureTag, Constructor);
    addTag(fontTag, fontConstructor);
    addTag(footerTag, Constructor);
    addTag(formTag, formConstructor);
    addTag(frameTag, frameConstructor);
    addTag(framesetTag, framesetConstructor);
    addTag(h1Tag, headingConstructor);
    addTag(h2Tag, headingConstructor);
    addTag(h3Tag, headingConstructor);
    addTag(h4Tag, headingConstructor);
    addTag(h5Tag, headingConstructor);
    addTag(h6Tag, headingConstructor);
    addTag(headTag, headConstructor);
    addTag(headerTag, Constructor);
    addTag(hgroupTag, Constructor);
    addTag(hrTag, hrConstructor);
    addTag(htmlTag, htmlConstructor);
    addTag(iTag, Constructor);
    addTag(iframeTag, iframeConstructor);
    addTag(imageTag, Constructor);
    addTag(imgTag, imageConstructor);
    addTag(inputTag, inputConstructor);
    addTag(insTag, modConstructor);
    addTag(isindexTag, unknownConstructor);
    addTag(kbdTag, Constructor);
    addTag(keygenTag, keygenConstructor);
    addTag(labelTag, labelConstructor);
    addTag(layerTag, Constructor);
    addTag(legendTag, legendConstructor);
    addTag(liTag, liConstructor);
    addTag(linkTag, linkConstructor);
    addTag(listingTag, preConstructor);
    addTag(mainTag, Constructor);
    addTag(mapTag, mapConstructor);
    addTag(markTag, Constructor);
    addTag(marqueeTag, marqueeConstructor);
    addTag(menuTag, menuConstructor);
    addTag(metaTag, metaConstructor);
#if ENABLE(METER_ELEMENT)
    addTag(meterTag, meterConstructor);
#endif

    addTag(navTag, Constructor);
    addTag(nobrTag, Constructor);
    addTag(noembedTag, Constructor);
    addTag(noframesTag, Constructor);
    addTag(nolayerTag, Constructor);
    addTag(noscriptTag, Constructor);
    addTag(objectTag, objectConstructor);
    addTag(olTag, olistConstructor);
    addTag(optgroupTag, optgroupConstructor);
    addTag(optionTag, optionConstructor);
    addTag(outputTag, outputConstructor);
    addTag(pTag, paragraphConstructor);
    addTag(paramTag, paramConstructor);
    addTag(plaintextTag, Constructor);
    addTag(preTag, preConstructor);
#if ENABLE(PROGRESS_ELEMENT)
    addTag(progressTag, progressConstructor);
#endif

    addTag(qTag, quoteConstructor);
    addTag(rpTag, Constructor);
    addTag(rtTag, Constructor);
    addTag(rubyTag, Constructor);
    addTag(sTag, Constructor);
    addTag(sampTag, Constructor);
    addTag(scriptTag, scriptConstructor);
    addTag(sectionTag, Constructor);
    addTag(selectTag, selectConstructor);
    addTag(smallTag, Constructor);
#if ENABLE(VIDEO)
    addTag(sourceTag, sourceConstructor);
#endif

    addTag(spanTag, spanConstructor);
    addTag(strikeTag, Constructor);
    addTag(strongTag, Constructor);
    addTag(styleTag, styleConstructor);
    addTag(subTag, Constructor);
#if ENABLE(DETAILS_ELEMENT)
    addTag(summaryTag, summaryConstructor);
#endif

    addTag(supTag, Constructor);
    addTag(tableTag, tableConstructor);
    addTag(tbodyTag, tablesectionConstructor);
    addTag(tdTag, tablecellConstructor);
#if ENABLE(TEMPLATE_ELEMENT)
    addTag(templateTag, templateConstructor);
#endif

    addTag(textareaTag, textareaConstructor);
    addTag(tfootTag, tablesectionConstructor);
    addTag(thTag, tablecellConstructor);
    addTag(theadTag, tablesectionConstructor);
    addTag(titleTag, titleConstructor);
    addTag(trTag, tablerowConstructor);
#if ENABLE(VIDEO_TRACK)
    addTag(trackTag, trackConstructor);
#endif

    addTag(ttTag, Constructor);
    addTag(uTag, Constructor);
    addTag(ulTag, ulistConstructor);
    addTag(varTag, Constructor);
#if ENABLE(VIDEO)
    addTag(videoTag, videoConstructor);
#endif

    addTag(wbrTag, Constructor);
    addTag(xmpTag, preConstructor);
}

PassRefPtr<HTMLElement> HTMLElementFactory::createHTMLElement(const QualifiedName& qName, Document* document, HTMLFormElement* formElement, bool createdByParser)
{
    if (!document)
        return 0;

#if ENABLE(CUSTOM_ELEMENTS)
    if (document->registry()) {
        if (RefPtr<CustomElementConstructor> constructor = document->registry()->find(nullQName(), qName)) {
            RefPtr<Element> element = constructor->createElement();
            ASSERT(element->isHTMLElement());
            return static_pointer_cast<HTMLElement>(element.release());
        }
    }
#endif

    if (!gFunctionMap)
        createFunctionMap();
    if (ConstructorFunction function = gFunctionMap->get(qName.localName().impl())) {
        if (PassRefPtr<HTMLElement> element = function(qName, document, formElement, createdByParser))
            return element;
    }

    return HTMLUnknownElement::create(qName, document);
}

} // namespace WebCore

